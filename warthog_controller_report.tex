\chapter{Warthog Controller Package}

\section{Package Creation}

The \texttt{warthog\_controller} package was created using the ROS 2 package creation command in the \texttt{warthog\_ws/src} directory:

\begin{verbatim}
ros2 pkg create --build-type ament_python warthog_controller
\end{verbatim}

The \texttt{ament\_python} build type was selected for this package due to Python's simplicity and rapid development capabilities. Python offers a more straightforward syntax compared to C++, making it ideal for quick prototyping and educational purposes, while still providing full access to ROS 2 functionality through the \texttt{rclpy} library.

\section{Command Publisher Node}

\subsection{File Structure}

The main controller node was implemented in the file \texttt{cmd\_pub.py}, located at:
\begin{verbatim}
src/warthog_controller/warthog_controller/cmd_pub.py
\end{verbatim}

This file structure follows the ROS 2 Python package convention where the package name is repeated as a subdirectory to contain the Python modules.

\subsection{Node Implementation}

The \texttt{cmd\_pub.py} file implements a simple velocity command publisher node. The code structure is as follows:

\subsubsection{Imports}
\begin{verbatim}
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
\end{verbatim}

The node imports three essential components:
\begin{itemize}
    \item \texttt{rclpy}: The ROS 2 Python client library that provides the core functionality for creating ROS 2 nodes
    \item \texttt{Node}: The base class from which all ROS 2 nodes inherit
    \item \texttt{Twist}: The message type used to represent velocity commands
\end{itemize}

\subsubsection{CmdPub Class}

The \texttt{CmdPub} class inherits from \texttt{Node} and implements the following functionality:

\paragraph{Initialization}
\begin{verbatim}
def __init__(self):
    super().__init__('cmd_pub')
    self.publisher_ = self.create_publisher(Twist, 'cmd_vel', 10)
    timer_period = 0.5  # seconds for publishing rate
    self.timer = self.create_timer(timer_period, self.timer_callback)
\end{verbatim}

The constructor performs several key operations:
\begin{enumerate}
    \item Initializes the parent \texttt{Node} class with the node name \texttt{'cmd\_pub'}
    \item Creates a publisher that publishes \texttt{Twist} messages to the \texttt{cmd\_vel} topic with a queue size of 10
    \item Sets up a timer with a period of 0.5 seconds (2 Hz publishing rate)
    \item Registers the \texttt{timer\_callback} method to be called at each timer interval
\end{enumerate}

\paragraph{Timer Callback}
\begin{verbatim}
def timer_callback(self):
    msg = Twist()
    msg.linear.x = 1.0  # Set linear velocity
    msg.angular.z = 0.5  # Set angular velocity
    self.publisher_.publish(msg)
    self.get_logger().info('Publishing: Linear X: %.2f, Angular Z: %.2f' 
                           % (msg.linear.x, msg.angular.z))
\end{verbatim}

The timer callback method executes at the specified rate and:
\begin{enumerate}
    \item Creates a new \texttt{Twist} message instance
    \item Sets the linear velocity in the x-direction to 1.0 m/s (forward motion)
    \item Sets the angular velocity around the z-axis to 0.5 rad/s (rotation)
    \item Publishes the message to the \texttt{cmd\_vel} topic
    \item Logs the published values for monitoring and debugging
\end{enumerate}

\paragraph{Main Function}
\begin{verbatim}
def main(args=None):
    rclpy.init(args=args)
    cmd_pub = CmdPub()
    rclpy.spin(cmd_pub)
    cmd_pub.destroy_node()
    rclpy.shutdown()
\end{verbatim}

The main function serves as the entry point for the node and:
\begin{enumerate}
    \item Initializes the ROS 2 Python client library
    \item Creates an instance of the \texttt{CmdPub} node
    \item Calls \texttt{spin()} to keep the node running and processing callbacks
    \item Cleans up by destroying the node when interrupted
    \item Shuts down the ROS 2 context
\end{enumerate}

\section{Twist Message Definition}

\subsection{Twist Message Structure}

The \texttt{geometry\_msgs/Twist} message is used to express velocity in free space. The raw message definition is:

\begin{verbatim}
# This expresses velocity in free space broken into its linear 
# and angular parts.
Vector3 linear
Vector3 angular
\end{verbatim}

This message type decomposes the velocity into two fundamental components:
\begin{itemize}
    \item \textbf{linear}: A \texttt{Vector3} representing the linear velocity components (translational motion)
    \item \textbf{angular}: A \texttt{Vector3} representing the angular velocity components (rotational motion)
\end{itemize}

\subsection{Vector3 Message Definition}

The \texttt{Vector3} message type is defined as:

\begin{verbatim}
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
\end{verbatim}

The \texttt{Vector3} message contains three 64-bit floating-point fields:
\begin{itemize}
    \item \textbf{x}: Component along the x-axis
    \item \textbf{y}: Component along the y-axis
    \item \textbf{z}: Component along the z-axis
\end{itemize}

It is important to note that \texttt{Vector3} is specifically designed to represent directions and velocities, not positions. When coordinate transformations are applied (such as with \texttt{tf2}), only rotations are applied to \texttt{Vector3} objects, not translations. For representing points in space that should undergo both rotational and translational transformations, the \texttt{geometry\_msgs/Point} message should be used instead.

\subsection{Velocity Representation}

In the context of robot control, the \texttt{Twist} message provides a complete representation of the robot's desired velocity:

\begin{itemize}
    \item \textbf{linear.x}: Forward/backward velocity (m/s)
    \item \textbf{linear.y}: Left/right velocity (m/s) - used for holonomic robots
    \item \textbf{linear.z}: Up/down velocity (m/s) - used for aerial vehicles
    \item \textbf{angular.x}: Roll rate (rad/s)
    \item \textbf{angular.y}: Pitch rate (rad/s)
    \item \textbf{angular.z}: Yaw rate (rad/s) - used for ground robots
\end{itemize}

For a differential drive robot like the Warthog, typically only \texttt{linear.x} (forward/backward) and \texttt{angular.z} (rotation) are used, as these robots are non-holonomic and operate on a 2D plane.

\section{The cmd\_vel Topic}

\subsection{Topic Purpose}

The \texttt{cmd\_vel} topic is a standard ROS convention for commanding velocity to mobile robots. This topic:
\begin{itemize}
    \item Accepts messages of type \texttt{geometry\_msgs/Twist}
    \item Serves as the primary interface for velocity control
    \item Is monitored by robot controllers and simulators
    \item Allows decoupling between high-level planning and low-level control
\end{itemize}

\subsection{Message Flow}

The typical message flow for velocity commands is:
\begin{enumerate}
    \item A velocity command node (like \texttt{cmd\_pub}) publishes \texttt{Twist} messages to \texttt{cmd\_vel}
    \item The robot's controller subscribes to \texttt{cmd\_vel}
    \item The controller translates the velocity commands into wheel speeds or actuator commands
    \item The robot executes the motion
\end{enumerate}

This standardized interface allows different navigation algorithms, teleoperation nodes, or autonomous behaviors to control the robot using the same topic, without needing to know the specific hardware implementation details.

\section{Package Configuration}

\subsection{Setup File Entry Point}

To make the \texttt{cmd\_pub} node executable as a ROS 2 node, it must be registered in the package's \texttt{setup.py} file. The relevant section is the \texttt{entry\_points} dictionary:

\begin{verbatim}
entry_points={
    'console_scripts': [
        'cmd_pub = warthog_controller.cmd_pub:main',
    ],
},
\end{verbatim}

\subsection{Purpose of Entry Points}

The entry point definition serves several critical functions:

\begin{enumerate}
    \item \textbf{Creates an executable command}: The entry point tells setuptools to create an executable script named \texttt{cmd\_pub} that can be invoked from the command line
    
    \item \textbf{Maps to the Python function}: The syntax \texttt{warthog\_controller.cmd\_pub:main} specifies:
    \begin{itemize}
        \item \texttt{warthog\_controller.cmd\_pub}: The Python module path
        \item \texttt{main}: The function to call when the executable is run
    \end{itemize}
    
    \item \textbf{Enables ROS 2 integration}: After building and sourcing the workspace, the node can be launched using:
    \begin{verbatim}
    ros2 run warthog_controller cmd_pub
    \end{verbatim}
    
    \item \textbf{Installation and PATH management}: When the package is built with \texttt{colcon build}, the executable is installed to the workspace's \texttt{install} directory and automatically added to the PATH when the workspace is sourced
\end{enumerate}

Without this entry point definition, the \texttt{cmd\_pub.py} file would exist as a Python module but would not be accessible as a ROS 2 node through the standard \texttt{ros2 run} command interface.

\section{Experimental Results}

The performance and behavior of the \texttt{cmd\_pub} node were analyzed using \texttt{rqt\_multiplot}, a visualization tool for ROS topics. The following figures show the velocity commands published over time.

\begin{figure}[htbp]
    \centering
    % \includegraphics[width=0.8\textwidth]{figures/linear_velocity.png}
    \caption{Linear velocity (x-axis) published by the cmd\_pub node over time. The plot shows a constant value of 1.0 m/s, indicating steady forward motion.}
    \label{fig:linear_velocity}
\end{figure}

\begin{figure}[htbp]
    \centering
    % \includegraphics[width=0.8\textwidth]{figures/angular_velocity.png}
    \caption{Angular velocity (z-axis) published by the cmd\_pub node over time. The plot shows a constant value of 0.5 rad/s, resulting in a circular motion pattern.}
    \label{fig:angular_velocity}
\end{figure}

\begin{figure}[htbp]
    \centering
    % \includegraphics[width=0.8\textwidth]{figures/combined_plot.png}
    \caption{Combined visualization of linear and angular velocities, demonstrating the constant velocity profile generated by the timer callback at 2 Hz.}
    \label{fig:combined_velocity}
\end{figure}

The results demonstrate that the \texttt{cmd\_pub} node successfully publishes consistent velocity commands at the specified rate. The combination of constant forward linear velocity and rotational angular velocity would cause the robot to move in a circular arc pattern.

\section{Conclusion}

The \texttt{warthog\_controller} package demonstrates the fundamental concepts of ROS 2 node development in Python, including:
\begin{itemize}
    \item Creating publishers for standard message types
    \item Using timers for periodic execution
    \item Understanding the \texttt{Twist} message structure for velocity control
    \item Properly configuring Python packages for ROS 2 integration
\end{itemize}

This simple controller serves as a foundation that can be extended to implement more sophisticated behaviors such as trajectory following, obstacle avoidance, or integration with navigation stacks.
